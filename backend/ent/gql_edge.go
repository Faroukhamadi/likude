// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
)

func (c *Comment) Post(ctx context.Context) ([]*Post, error) {
	result, err := c.Edges.PostOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryPost().All(ctx)
	}
	return result, err
}

func (c *Comment) Replies(ctx context.Context) ([]*Reply, error) {
	result, err := c.Edges.RepliesOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryReplies().All(ctx)
	}
	return result, err
}

func (c *Community) Users(ctx context.Context) ([]*User, error) {
	result, err := c.Edges.UsersOrErr()
	if IsNotLoaded(err) {
		result, err = c.QueryUsers().All(ctx)
	}
	return result, err
}

func (po *Post) Writer(ctx context.Context) ([]*User, error) {
	result, err := po.Edges.WriterOrErr()
	if IsNotLoaded(err) {
		result, err = po.QueryWriter().All(ctx)
	}
	return result, err
}

func (po *Post) Comments(ctx context.Context) ([]*Comment, error) {
	result, err := po.Edges.CommentsOrErr()
	if IsNotLoaded(err) {
		result, err = po.QueryComments().All(ctx)
	}
	return result, err
}

func (r *Reply) Comment(
	ctx context.Context, after *Cursor, first *int, before *Cursor, last *int, orderBy *CommentOrder, where *CommentWhereInput,
) (*CommentConnection, error) {
	opts := []CommentPaginateOption{
		WithCommentOrder(orderBy),
		WithCommentFilter(where.Filter),
	}
	totalCount := r.Edges.totalCount[0]
	if nodes, err := r.Edges.CommentOrErr(); err == nil || totalCount != nil {
		conn := &CommentConnection{Edges: []*CommentEdge{}}
		if totalCount != nil {
			conn.TotalCount = *totalCount
		}
		pager, err := newCommentPager(opts)
		if err != nil {
			return nil, err
		}
		conn.build(nodes, pager, after, first, before, last)
		return conn, nil
	}
	query := r.QueryComment()
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCommentPager(opts)
	if err != nil {
		return nil, err
	}
	if query, err = pager.applyFilter(query); err != nil {
		return nil, err
	}
	conn := &CommentConnection{Edges: []*CommentEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
			if totalCount != nil {
				conn.TotalCount = *totalCount
			} else if conn.TotalCount, err = query.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := query.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	query = pager.applyCursors(query, after, before)
	query = pager.applyOrder(query, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		query.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := query.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := query.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

func (t *Topic) RelatedTopics(ctx context.Context) ([]*Topic, error) {
	result, err := t.Edges.RelatedTopicsOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryRelatedTopics().All(ctx)
	}
	return result, err
}

func (t *Topic) TopicRelations(ctx context.Context) ([]*TopicRelated, error) {
	result, err := t.Edges.TopicRelationsOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryTopicRelations().All(ctx)
	}
	return result, err
}

func (tr *TopicRelated) Topic(ctx context.Context) (*Topic, error) {
	result, err := tr.Edges.TopicOrErr()
	if IsNotLoaded(err) {
		result, err = tr.QueryTopic().Only(ctx)
	}
	return result, err
}

func (tr *TopicRelated) RelatedTopic(ctx context.Context) (*Topic, error) {
	result, err := tr.Edges.RelatedTopicOrErr()
	if IsNotLoaded(err) {
		result, err = tr.QueryRelatedTopic().Only(ctx)
	}
	return result, err
}

func (u *User) Posts(ctx context.Context) ([]*Post, error) {
	result, err := u.Edges.PostsOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryPosts().All(ctx)
	}
	return result, err
}

func (u *User) Communities(ctx context.Context) ([]*Community, error) {
	result, err := u.Edges.CommunitiesOrErr()
	if IsNotLoaded(err) {
		result, err = u.QueryCommunities().All(ctx)
	}
	return result, err
}
